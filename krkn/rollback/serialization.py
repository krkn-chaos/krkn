from typing import Callable, Optional, Any

import inspect
import os
import logging
import time
from dataclasses import dataclass
from typing import TYPE_CHECKING

from krkn_lib.k8s import KrknKubernetes
from krkn_lib.telemetry.ocp import KrknTelemetryOpenshift
from krkn_lib.models.telemetry import ScenarioTelemetry
from krkn.rollback.config import RollbackConfig

if TYPE_CHECKING:
    from krkn.rollback.config import RollbackContext

logger = logging.getLogger(__name__)

VERSION_FILE_TEMPLATE = """# This file is auto-generated by krkn-lib.
# It contains the rollback callable and its arguments for the scenario plugin.
{IMPORTS}
# Rollback callable implementation
{ROLLBACK_CALLABLE_CODE}
# Setup for execution
# Create necessary variables for execution
{KRKN_LIB_VARS}
# Execute the rollback callable
if __name__ == '__main__':
{SETUP_KRKN_LIB}
    print('Executing rollback callable...')
    rollback_callable({ALL_ARGS})
    print('Rollback completed.')
"""

@dataclass
class Version:
    rollback_callable_code: str
    has_lib_telemetry: bool = False
    has_kubecli: bool = False
    has_scenario_telemetry: bool = False
    serialized_arguments: Optional[list[Any]] = None
    serialized_kwargs: Optional[dict[str, Any]] = None
    timestamp: int = time.time_ns() # Get current timestamp in nanoseconds
    hash_suffix: str = os.urandom(4).hex() # Generate a random 4-byte hexadecimal string

    @property
    def version_file_name(self) -> str:
        """
        Generate a version file name based on the timestamp and hash suffix.
        :return: The generated version file name.
        """
        return f"rollback_{self.timestamp}_{self.hash_suffix}.py"


class Serializer:
    def __init__(self, scenario_type: str):
        self.scenario_type = scenario_type
        self.rollback_context: RollbackConfig | None = None # This will be set later by the RollbackHandler

    def set_context(self, rollback_context: "RollbackContext"):
        """
        Set the context for the serializer.
        :param rollback_context: The rollback context to be set.
        """
        self.rollback_context = rollback_context

    def clear_context(self):
        """
        Clear the context for the serializer.
        This will reset the run_uuid.
        """
        self.rollback_context = None

    def _get_version_file_full_path(self, version: Version) -> str:
        """
        Get the full path for the version file based on the version object and current context.

        :param version: The version object containing details for the file path.
        :return: The generated version file path.
        """
        if not self.rollback_context:
            raise ValueError("Must run set_context(rollback_context) before serializing a callable.")

        return f"{RollbackConfig.get_rollback_versions_directory(self.scenario_type, self.rollback_context)}/{version.version_file_name}"

    def _serialize_argument(self, argument: Any) -> str:
        """
        Serialize an argument to a string representation.
        :param argument: The argument to serialize.
        :return: The serialized argument as a string.
        """
        # krkn-lib
        if isinstance(argument, KrknTelemetryOpenshift):
            return "lib_telemetry"
        elif isinstance(argument, KrknKubernetes):
            return "kubecli"
        elif isinstance(argument, ScenarioTelemetry):
            return "scenario_telemetry"

        # basic types
        if argument is None:
            return "None"
        elif isinstance(argument, bool):
            return "True" if argument else "False"
        elif isinstance(argument, str):
            return f'"{argument}"'
        elif isinstance(argument, (int, float)):
            return str(argument)
        elif isinstance(argument, list):
            return "[" + ", ".join(self._serialize_argument(a) for a in argument) + "]"
        elif isinstance(argument, dict):
            return "{" + ", ".join(f'"{k}": {self._serialize_argument(v)}' for k, v in argument.items()) + "}"
        elif isinstance(argument, tuple):
            return "(" + ", ".join(self._serialize_argument(a) for a in argument) + ")"
        else:
            return repr(argument)

    def _parse_rollback_callable_code(self, callable: Callable) -> str:
        """
        Parse the rollback callable code to extract its implementation.
        :param callable: The callable function to parse.
        :return: The source code of the callable.
        """
        # Get the implementation code of the rollback_callable
        rollback_callable_code = inspect.getsource(callable)

        # Remove @staticmethod decorator and fix indentation
        code_lines = rollback_callable_code.split("\n")
        cleaned_lines = []

        # Skip the @staticmethod line if present
        for i, line in enumerate(code_lines):
            if "@staticmethod" in line:
                continue

            # For the first line containing def, remove any indentation
            if "def rollback_callable" in line:
                # Remove indentation from method signature
                cleaned_lines.append(line.lstrip())
                # Adjust indentation for all subsequent lines to match the function level
                indent_level = len(line) - len(line.lstrip())
                for j in range(i + 1, len(code_lines)):
                    if code_lines[j].strip():  # If not empty line
                        # Remove original indentation and keep only the relative indentation
                        relative_indent = (
                            code_lines[j][indent_level:] if len(code_lines[j]) > indent_level else ""
                        )
                        cleaned_lines.append(relative_indent)
                break

        # Reconstruct the code with proper indentation
        rollback_callable_code = "\n".join(cleaned_lines)
        return rollback_callable_code.strip()

    def _parse_arguments(self, arguments=()) -> list[str]:
        """
        Parse the arguments to a list of serialized strings.
        :param arguments: Tuple of arguments to serialize.
        :return: List of serialized argument strings.
        """
        return [self._serialize_argument(arg) for arg in arguments]

    def _parse_kwargs(self, kwargs=None) -> dict[str, Any]:
        """
        Parse the keyword arguments to a dictionary of serialized strings.
        :param kwargs: Dictionary of keyword arguments to serialize.
        :return: Dictionary of serialized keyword argument strings.
        """
        if kwargs is None:
            return {}

        return {key: self._serialize_argument(value) for key, value in kwargs.items()}

    def _has_krkn_lib_obj(self, cls, arguments=(), kwargs=None) -> bool:
        """
        Check if the arguments or keyword arguments contain an instance of the specified class.
        :param arguments: Tuple of arguments to check.
        :param kwargs: Dictionary of keyword arguments to check.
        :param cls: The class to check for instances of.
        :return: True if an instance of cls is found, False otherwise.
        """
        if isinstance(arguments, tuple):
            for arg in arguments:
                if isinstance(arg, cls):
                    return True
        if kwargs:
            for value in kwargs.values():
                if isinstance(value, cls):
                    return True
        return False

    def _get_imports(self, version: Version) -> str:
        """
        Generate import statements based on the version's attributes.
        :param version: The Version object containing attributes to check.
        :return: A string of import statements.
        """
        imports = []
        if version.has_lib_telemetry:
            imports.append("from krkn_lib.utils import SafeLogger")
            imports.append("from krkn_lib.ocp import KrknOpenshift")
            imports.append("from krkn_lib.telemetry.ocp import KrknTelemetryOpenshift")

        if version.has_kubecli:
            imports.append("from krkn_lib.k8s import KrknKubernetes")
        if version.has_scenario_telemetry:
            imports.append("from krkn_lib.models.telemetry import ScenarioTelemetry")

        if imports:
            imports.insert(0, "import os")

        return "\n".join(imports)

    def _get_krkn_lib_vars(self, version: Version) -> str:
        """
        Generate variables for the Kraken library based on the version's attributes.
        :param version: The Version object containing attributes to check.
        :return: A string of variable assignments.
        """
        lib_vars = []
        if version.has_lib_telemetry:
            lib_vars.append("lib_telemetry = None")
        if version.has_kubecli:
            lib_vars.append("kubecli = None")
        if version.has_scenario_telemetry:
            lib_vars.append("scenario_telemetry = None")

        return "\n".join(lib_vars)

    def _get_setup_krkn_lib(self, version: Version) -> str:
        """
        Generate setup code for Kraken library objects.
        :param version: The Version object containing attributes to check.
        :return: A string of setup code.
        """
        setup_lines = []

        if version.has_kubecli:
            setup_lines.append("    kubecli = KrknKubernetes(kubeconfig_path=kubeconfig_path)")

        if version.has_lib_telemetry:
            # We need to add lib_openshift and safe_logger setup for lib_telemetry
            setup_lines.append("    log_directory = os.path.dirname(os.path.abspath(__file__))")
            setup_lines.append("    os.makedirs(os.path.join(log_directory, 'logs'), exist_ok=True)")
            setup_lines.append(
                "    telemetry_log_path = os.path.join(log_directory, 'logs', 'telemetry.log')"
            )
            setup_lines.append("    safe_logger = SafeLogger(telemetry_log_path)")
            setup_lines.append("    \n")
            setup_lines.append("    lib_openshift = KrknOpenshift(kubeconfig_path=kubeconfig_path)")
            setup_lines.append(
                "    lib_telemetry = KrknTelemetryOpenshift(safe_logger=safe_logger, lib_openshift=lib_openshift)"
            )

        if version.has_scenario_telemetry:
            setup_lines.append("    scenario_telemetry = ScenarioTelemetry(kubeconfig_path=kubeconfig_path)")

        if setup_lines:
            setup_lines.insert(0, "    kubeconfig_path = os.getenv('KUBECONFIG', '/path/to/your/kubeconfig')")
            setup_lines.append("    \n")

        return "\n".join(setup_lines)

    def _format_all_args(self, version: Version) -> str:
        """
        Format all arguments for the rollback_callable function call.
        :param version: The Version object containing serialized arguments and kwargs.
        :return: A string representation of all arguments for the function call.
        """
        args_parts = []

        # Add serialized positional arguments
        if version.serialized_arguments:
            args_parts.extend(version.serialized_arguments)

        # Add serialized keyword arguments
        if version.serialized_kwargs:
            args_parts.extend([f"{k}={v}" for k, v in version.serialized_kwargs.items()])

        return ", ".join(args_parts)

    def serialize_callable(self, callable: Callable, arguments=(), kwargs=None) -> str:
        """
        Serialize a callable function to a file with its arguments and keyword arguments.
        :param callable: The callable to serialize.
        :param arguments: Tuple of arguments for the callable.
        :param kwargs: Dictionary of keyword arguments for the callable.
        :return: Path to the serialized callable file.
        """
        # Check if callable is AbstractScenarioPlugin.rollback_callable staticmethod
        from krkn.scenario_plugins.abstract_scenario_plugin import AbstractScenarioPlugin

        if not (
            hasattr(callable, "__qualname__")
            and callable.__qualname__.endswith(".rollback_callable")
            and hasattr(callable, "__func__")
            and callable.__func__.__name__ == "rollback_callable"
        ):
            logger.warning(
                "The callable may not be an AbstractScenarioPlugin.rollback_callable staticmethod"
            )

        version = Version(
            rollback_callable_code=self._parse_rollback_callable_code(callable),
            has_lib_telemetry=self._has_krkn_lib_obj(KrknTelemetryOpenshift, arguments, kwargs),
            has_kubecli=self._has_krkn_lib_obj(KrknKubernetes, arguments, kwargs),
            has_scenario_telemetry=self._has_krkn_lib_obj(ScenarioTelemetry, arguments, kwargs),
            serialized_arguments=self._parse_arguments(arguments=arguments),
            serialized_kwargs=self._parse_kwargs(kwargs),
        )

        # Generate file content using the VERSION_FILE_TEMPLATE
        file_content = VERSION_FILE_TEMPLATE.format(
            IMPORTS=self._get_imports(version),
            ROLLBACK_CALLABLE_CODE=version.rollback_callable_code,
            KRKN_LIB_VARS=self._get_krkn_lib_vars(version),
            SETUP_KRKN_LIB=self._get_setup_krkn_lib(version),
            ALL_ARGS=self._format_all_args(version),
        )

        # Write the file to the version directory
        version_file_full_path = self._get_version_file_full_path(version)
        os.makedirs(os.path.dirname(version_file_full_path), exist_ok=True)

        logger.debug("Creating version file at %s", version_file_full_path)
        logger.debug("Version file content:\n%s", file_content)
        with open(version_file_full_path, "w") as f:
            f.write(file_content)
        logger.info(f"Serialized callable written to {version_file_full_path}")

        return version_file_full_path