from typing import Callable, Optional, Any

import inspect
import os
import logging
import time
from dataclasses import dataclass
from typing import TYPE_CHECKING

from krkn_lib.k8s import KrknKubernetes
from krkn_lib.telemetry.ocp import KrknTelemetryOpenshift
from krkn_lib.models.telemetry import ScenarioTelemetry
from krkn.rollback.config import RollbackConfig

if TYPE_CHECKING:
    from krkn.rollback.config import RollbackContext, RollbackCallable, RollbackContent

logger = logging.getLogger(__name__)

VERSION_FILE_TEMPLATE = """# This file is auto-generated by krkn-lib.
# It contains the rollback callable and its arguments for the scenario plugin.

import os
import logging
from typing import TypedDict

from krkn_lib.utils import SafeLogger
from krkn_lib.ocp import KrknOpenshift
from krkn_lib.telemetry.ocp import KrknTelemetryOpenshift

{ROLLBACK_CONTENT_DEFINITION}

# Actual rollback callable
{ROLLBACK_CALLABLE_CODE}

# Create necessary variables for execution
lib_openshift = None
lib_telemetry = None


# Main entry point for execution
if __name__ == '__main__':
    # setup logging
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s [%(levelname)s] %(message)s",
        handlers=[
            logging.StreamHandler(),
        ]
    )

    # setup logging and get kubeconfig path
    kubeconfig_path = os.getenv("KUBECONFIG", "~/.kube/config")
    log_directory = os.path.dirname(os.path.abspath(__file__))
    os.makedirs(os.path.join(log_directory, 'logs'), exist_ok=True)
    # setup SafeLogger for telemetry
    telemetry_log_path = os.path.join(log_directory, 'logs', 'telemetry.log')
    safe_logger = SafeLogger(telemetry_log_path)
    # setup krkn-lib objects
    lib_openshift = KrknOpenshift(kubeconfig_path=kubeconfig_path)
    lib_telemetry = KrknTelemetryOpenshift(safe_logger=safe_logger, lib_openshift=lib_openshift)

    # execute
    logging.info('Executing rollback callable...')
    {ROLLBACK_CALLABLE_NAME}({ALL_ARGS})
    logging.info('Rollback completed.')
"""


@dataclass
class Version:
    rollback_callable_name: str
    rollback_callable_code: str
    rollback_content_definition: str
    rollback_content: "RollbackContent"
    timestamp: int = time.time_ns()  # Get current timestamp in nanoseconds
    hash_suffix: str = os.urandom(
        4
    ).hex()  # Generate a random 4-byte hexadecimal string

    @property
    def version_file_name(self) -> str:
        """
        Generate a version file name based on the timestamp and hash suffix.
        :return: The generated version file name.
        """
        return f"rollback_{self.timestamp}_{self.hash_suffix}.py"


class Serializer:
    def __init__(self, scenario_type: str):
        self.scenario_type = scenario_type
        self.rollback_context: RollbackConfig | None = (
            None  # This will be set later by the RollbackHandler
        )

    def set_context(self, rollback_context: "RollbackContext"):
        """
        Set the context for the serializer.
        :param rollback_context: The rollback context to be set.
        """
        self.rollback_context = rollback_context

    def clear_context(self):
        """
        Clear the context for the serializer.
        This will reset the run_uuid.
        """
        self.rollback_context = None

    def _get_version_file_full_path(self, version: Version) -> str:
        """
        Get the full path for the version file based on the version object and current context.

        :param version: The version object containing details for the file path.
        :return: The generated version file path.
        """
        if not self.rollback_context:
            raise ValueError(
                "Must run set_context(rollback_context) before serializing a callable."
            )

        return f"{RollbackConfig.get_scenario_rollback_versions_directory(self.scenario_type, self.rollback_context)}/{version.version_file_name}"

    def _serialize_argument(self, argument: Any) -> str:
        """
        Serialize an argument to a string representation.
        :param argument: The argument to serialize.
        :return: The serialized argument as a string.
        """
        # krkn-lib
        if isinstance(argument, KrknTelemetryOpenshift):
            return "lib_telemetry"
        elif isinstance(argument, KrknKubernetes):
            return "kubecli"
        elif isinstance(argument, ScenarioTelemetry):
            return "scenario_telemetry"

        # basic types
        if argument is None:
            return "None"
        elif isinstance(argument, bool):
            return "True" if argument else "False"
        elif isinstance(argument, str):
            return f'"{argument}"'
        elif isinstance(argument, (int, float)):
            return str(argument)
        elif isinstance(argument, list):
            return "[" + ", ".join(self._serialize_argument(a) for a in argument) + "]"
        elif isinstance(argument, dict):
            return (
                "{"
                + ", ".join(
                    f'"{k}": {self._serialize_argument(v)}' for k, v in argument.items()
                )
                + "}"
            )
        elif isinstance(argument, tuple):
            return "(" + ", ".join(self._serialize_argument(a) for a in argument) + ")"
        else:
            return repr(argument)

    def _parse_rollback_content_definition(self, callable: "RollbackCallable") -> str:
        """
        Parse the rollback content definition from the callable's signature.
        Extracts the rollback content class and converts it to use dict instead of RollbackContent.

        :param callable: The callable function to parse.
        :return: The rollback content class definition as a string with dict base class.
        """
        # Get the signature of the callable
        sig = inspect.signature(callable)

        # Get the first parameter (should be rollback_content)
        params = list(sig.parameters.values())
        if not params:
            raise ValueError("Callable has no parameters")

        first_param = params[0]
        if not first_param.annotation:
            raise ValueError("First parameter has no type annotation")

        # Extract the type annotation
        rollback_content_type = first_param.annotation

        # If it's a string annotation (forward reference), we need to resolve it
        if isinstance(rollback_content_type, str):
            # Try to find the class definition in the callable's module
            module = inspect.getmodule(callable)
            if module and hasattr(module, rollback_content_type):
                rollback_content_type = getattr(module, rollback_content_type)
            else:
                raise ValueError(
                    f"Could not resolve type annotation: {rollback_content_type}"
                )

        # Get the source code of the rollback content class
        try:
            class_source = inspect.getsource(rollback_content_type)
        except OSError:
            raise ValueError(
                f"Could not get source code for class: {rollback_content_type.__name__}"
            )

        # Parse the class definition and replace RollbackContent with TypedDict
        lines = class_source.split("\n")
        modified_lines = []

        for line in lines:
            if line.strip().startswith("class ") and "(RollbackContent)" in line:
                # Replace RollbackContent with TypedDict
                modified_line = line.replace("(RollbackContent)", "(TypedDict)")
                modified_lines.append(modified_line)
            elif line.strip() and not line.strip().startswith("#"):
                # Keep other non-empty, non-comment lines
                modified_lines.append(line)

        # Join the lines back together
        modified_class_definition = "\n".join(modified_lines)

        return modified_class_definition.strip()

    def _parse_rollback_callable_code(
        self, callable: "RollbackCallable"
    ) -> tuple[str, str]:
        """
        Parse the rollback callable code to extract its implementation.
        :param callable: The callable function to parse (can be staticmethod or regular function).
        :return: A tuple containing (function_name, function_code).
        """
        # Get the implementation code of the rollback_callable
        rollback_callable_code = inspect.getsource(callable)

        # Split into lines for processing
        code_lines = rollback_callable_code.split("\n")
        cleaned_lines = []
        function_name = None

        # Find the function definition line and extract function name
        def_line_index = None
        for i, line in enumerate(code_lines):
            # Skip decorators (including @staticmethod)
            if line.strip().startswith("@"):
                continue

            # Look for function definition
            if line.strip().startswith("def "):
                def_line_index = i
                # Extract function name from the def line
                def_line = line.strip()
                if "(" in def_line:
                    function_name = def_line.split("def ")[1].split("(")[0].strip()
                break

        if def_line_index is None or function_name is None:
            raise ValueError(
                "Could not find function definition in callable source code"
            )

        # Get the base indentation level from the def line
        def_line = code_lines[def_line_index]
        base_indent_level = len(def_line) - len(def_line.lstrip())

        # Process all lines starting from the def line
        for i in range(def_line_index, len(code_lines)):
            line = code_lines[i]

            # Handle empty lines
            if not line.strip():
                cleaned_lines.append("")
                continue

            # Calculate current line's indentation
            current_indent = len(line) - len(line.lstrip())

            # Remove the base indentation to normalize to function level
            if current_indent >= base_indent_level:
                # Remove base indentation
                normalized_line = line[base_indent_level:]
                cleaned_lines.append(normalized_line)
            else:
                # This shouldn't happen in well-formed code, but handle it gracefully
                cleaned_lines.append(line.lstrip())

        # Reconstruct the code and clean up trailing whitespace
        function_code = "\n".join(cleaned_lines).rstrip()

        return function_name, function_code

    def _format_all_args(self, version: Version) -> str:
        """
        Format all arguments for the rollback_callable function call.
        :param version: The Version object containing serialized arguments and kwargs.
        :return: A string representation of all arguments for the function call.
        """
        args = [
            self._serialize_argument(version.rollback_content),
            "lib_telemetry",
        ]
        return ", ".join(args)

    def serialize_callable(
        self, callable: "RollbackCallable", rollback_content: "RollbackContent"
    ) -> str:
        """
        Serialize a callable function to a file with its arguments and keyword arguments.
        :param callable: The callable to serialize.
        :param rollback_content: The rollback content for the callable.
        :return: Path to the serialized callable file.
        """

        rollback_callable_name, rollback_callable_code = (
            self._parse_rollback_callable_code(callable)
        )
        version = Version(
            rollback_callable_name=rollback_callable_name,
            rollback_callable_code=rollback_callable_code,
            rollback_content_definition=self._parse_rollback_content_definition(
                callable
            ),
            rollback_content=rollback_content,
        )

        # Generate file content using the VERSION_FILE_TEMPLATE
        file_content = VERSION_FILE_TEMPLATE.format(
            ROLLBACK_CALLABLE_NAME=rollback_callable_name,
            ROLLBACK_CALLABLE_CODE=version.rollback_callable_code,
            ROLLBACK_CONTENT_DEFINITION=version.rollback_content_definition,
            ALL_ARGS=self._format_all_args(version),
        )

        # Write the file to the version directory
        version_file_full_path = self._get_version_file_full_path(version)
        os.makedirs(os.path.dirname(version_file_full_path), exist_ok=True)

        logger.debug("Creating version file at %s", version_file_full_path)
        logger.debug("Version file content:\n%s", file_content)
        with open(version_file_full_path, "w") as f:
            f.write(file_content)
        logger.info(f"Serialized callable written to {version_file_full_path}")

        return version_file_full_path
