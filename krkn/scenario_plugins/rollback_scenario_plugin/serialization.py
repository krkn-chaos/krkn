from typing import Callable, Optional, Any

import inspect
import os
import logging
import time
from dataclasses import dataclass

from krkn_lib.k8s import KrknKubernetes
from krkn_lib.telemetry.ocp import KrknTelemetryOpenshift
from krkn_lib.models.telemetry import ScenarioTelemetry


VERSION_FILE_TEMPLATE = """# This file is auto-generated by krkn-lib.
# It contains the rollback callable and its arguments for the scenario plugin.

{IMPORTS}

# Rollback callable implementation
{ROLLBACK_CALLABLE_CODE}
# Setup for execution
# Create necessary variables for execution
{KRKN_LIB_VARS}

# Execute the rollback callable
if __name__ == '__main__':
{SETUP_KRKN_LIB}
    print('Executing rollback callable...')
    rollback_callable({ALL_ARGS})
    print('Rollback completed.')
"""


@dataclass
class Version:
    rollback_callable_code: str
    has_lib_telemetry: bool = False
    has_kubecli: bool = False
    has_scenario_telemetry: bool = False
    serialized_arguments: Optional[list[Any]] = None
    serialized_kwargs: Optional[dict[str, Any]] = None
    timestamp: int = int(time.time())
    hash_suffix: str = os.urandom(4).hex()

    @property
    def version_file_name(self) -> str:
        """
        Generate a version file name based on the timestamp and hash suffix.
        :return: The generated version file name.
        """
        return f"rollback_{self.timestamp}_{self.hash_suffix}.py"


class Serializer:
    def __init__(self, version_directory: str):
        self.version_directory = version_directory

    def _generate_version_file_name(self):
        """
        Generate a version file name based on the current timestamp.
        :return: The generated version file name.
        """

        # Generate a random string based on the current time and a random number
        timestamp = int(time.time())
        hash_suffix = os.urandom(4).hex()
        return f"{self.version_directory}/rollback_{timestamp}_{hash_suffix}.py"

    def _serialize_argument(self, argument: Any) -> str:
        """
        Serialize an argument to a string representation.
        :param argument: The argument to serialize.
        :return: The serialized argument as a string.
        """
        # krkn-lib
        if isinstance(argument, KrknTelemetryOpenshift):
            return "lib_telemetry"
        elif isinstance(argument, KrknKubernetes):
            return "kubecli"
        elif isinstance(argument, ScenarioTelemetry):
            return "scenario_telemetry"

        # basic types
        if argument is None:
            return "None"
        elif isinstance(argument, bool):
            return "True" if argument else "False"
        elif isinstance(argument, str):
            return f'"{argument}"'
        elif isinstance(argument, (int, float)):
            return str(argument)
        elif isinstance(argument, list):
            return "[" + ", ".join(self._serialize_argument(a) for a in argument) + "]"
        elif isinstance(argument, dict):
            return "{" + ", ".join(f'"{k}": {self._serialize_argument(v)}' for k, v in argument.items()) + "}"
        elif isinstance(argument, tuple):
            return "(" + ", ".join(self._serialize_argument(a) for a in argument) + ")"
        else:
            return repr(argument)

    def _parse_rollback_callable_code(self, callable: Callable) -> str:
        """
        Parse the rollback callable code to extract its implementation.

        :param callable: The callable function to parse.
        :return: The source code of the callable.
        """
        # Get the implementation code of the rollback_callable
        rollback_callable_code = inspect.getsource(callable)

        # Remove @staticmethod decorator and fix indentation
        code_lines = rollback_callable_code.split("\n")
        cleaned_lines = []

        # Skip the @staticmethod line if present
        for i, line in enumerate(code_lines):
            if "@staticmethod" in line:
                continue

            # For the first line containing def, remove any indentation
            if "def rollback_callable" in line:
                # Remove indentation from method signature
                cleaned_lines.append(line.lstrip())
                # Adjust indentation for all subsequent lines to match the function level
                indent_level = len(line) - len(line.lstrip())
                for j in range(i + 1, len(code_lines)):
                    if code_lines[j].strip():  # If not empty line
                        # Remove original indentation and keep only the relative indentation
                        relative_indent = (
                            code_lines[j][indent_level:] if len(code_lines[j]) > indent_level else ""
                        )
                        cleaned_lines.append(relative_indent)
                break

        # Reconstruct the code with proper indentation
        rollback_callable_code = "\n".join(cleaned_lines)
        return rollback_callable_code.strip()

    def _parse_arguments(self, arguments=()) -> list[str]:
        """
        Parse the arguments to a list of serialized strings.

        :param arguments: Tuple of arguments to serialize.
        :return: List of serialized argument strings.
        """
        return [self._serialize_argument(arg) for arg in arguments]

    def _parse_kwargs(self, kwargs=None) -> dict[str, Any]:
        """
        Parse the keyword arguments to a dictionary of serialized strings.

        :param kwargs: Dictionary of keyword arguments to serialize.
        :return: Dictionary of serialized keyword argument strings.
        """
        if kwargs is None:
            return {}

        return {key: self._serialize_argument(value) for key, value in kwargs.items()}

    def _has_krkn_lib_obj(self, cls, arguments=(), kwargs=None) -> bool:
        """
        Check if the arguments or keyword arguments contain an instance of the specified class.

        :param arguments: Tuple of arguments to check.
        :param kwargs: Dictionary of keyword arguments to check.
        :param cls: The class to check for instances of.
        :return: True if an instance of cls is found, False otherwise.
        """
        if isinstance(arguments, tuple):
            for arg in arguments:
                if isinstance(arg, cls):
                    return True
        if kwargs:
            for value in kwargs.values():
                if isinstance(value, cls):
                    return True
        return False

    def _get_imports(self, version: Version) -> str:
        """
        Generate import statements based on the version's attributes.

        :param version: The Version object containing attributes to check.
        :return: A string of import statements.
        """
        imports = []
        if version.has_lib_telemetry:
            imports.append("from krkn_lib.utils import SafeLogger")
            imports.append("from krkn_lib.ocp import KrknOpenshift")
            imports.append("from krkn_lib.telemetry.ocp import KrknTelemetryOpenshift")

        if version.has_kubecli:
            imports.append("from krkn_lib.k8s import KrknKubernetes")
        if version.has_scenario_telemetry:
            imports.append("from krkn_lib.models.telemetry import ScenarioTelemetry")

        if imports:
            imports.insert(0, "import os")

        return "\n".join(imports)

    def _get_krkn_lib_vars(self, version: Version) -> str:
        """
        Generate variables for the Kraken library based on the version's attributes.

        :param version: The Version object containing attributes to check.
        :return: A string of variable assignments.
        """
        lib_vars = []
        if version.has_lib_telemetry:
            lib_vars.append("lib_telemetry = None")
        if version.has_kubecli:
            lib_vars.append("kubecli = None")
        if version.has_scenario_telemetry:
            lib_vars.append("scenario_telemetry = None")

        return "\n".join(lib_vars)

    def _get_setup_krkn_lib(self, version: Version) -> str:
        """
        Generate setup code for Kraken library objects.

        :param version: The Version object containing attributes to check.
        :return: A string of setup code.
        """
        setup_lines = []

        if version.has_kubecli:
            setup_lines.append("    kubecli = KrknKubernetes(kubeconfig_path=kubeconfig_path)")

        if version.has_lib_telemetry:
            # We need to add lib_openshift and safe_logger setup for lib_telemetry
            setup_lines.append("    log_directory = os.path.dirname(os.path.abspath(__file__))")
            setup_lines.append("    os.makedirs(os.path.join(log_directory, 'logs'), exist_ok=True)")
            setup_lines.append(
                "    telemetry_log_path = os.path.join(log_directory, 'logs', 'telemetry.log')"
            )
            setup_lines.append("    safe_logger = SafeLogger(telemetry_log_path)")
            setup_lines.append("    \n")
            setup_lines.append("    lib_openshift = KrknOpenshift(kubeconfig_path=kubeconfig_path)")
            setup_lines.append(
                "    lib_telemetry = KrknTelemetryOpenshift(safe_logger=safe_logger, lib_openshift=lib_openshift)"
            )

        if version.has_scenario_telemetry:
            setup_lines.append("    scenario_telemetry = ScenarioTelemetry(kubeconfig_path=kubeconfig_path)")

        if setup_lines:
            setup_lines.insert(0, "    kubeconfig_path = os.getenv('KUBECONFIG', '/path/to/your/kubeconfig')")
            setup_lines.append("    \n")

        return "\n".join(setup_lines)

    def _format_all_args(self, version: Version) -> str:
        """
        Format all arguments for the rollback_callable function call.

        :param version: The Version object containing serialized arguments and kwargs.
        :return: A string representation of all arguments for the function call.
        """
        args_parts = []

        # Add serialized positional arguments
        if version.serialized_arguments:
            args_parts.extend(version.serialized_arguments)

        # Add serialized keyword arguments
        if version.serialized_kwargs:
            args_parts.extend([f"{k}={v}" for k, v in version.serialized_kwargs.items()])

        return ", ".join(args_parts)

    def serialize_callable(self, callable: Callable, arguments=(), kwargs=None) -> str:
        """
        Serialize a callable function to a file with its arguments and keyword arguments.

        :param callable: The callable to serialize.
        :param arguments: Tuple of arguments for the callable.
        :param kwargs: Dictionary of keyword arguments for the callable.
        :return: Path to the serialized callable file.
        """
        # Check if callable is AbstractScenarioPlugin.rollback_callable staticmethod
        from krkn.scenario_plugins.abstract_scenario_plugin import AbstractScenarioPlugin

        if not (
            hasattr(callable, "__qualname__")
            and callable.__qualname__.endswith(".rollback_callable")
            and hasattr(callable, "__func__")
            and callable.__func__.__name__ == "rollback_callable"
        ):
            logging.warning(
                "The callable may not be an AbstractScenarioPlugin.rollback_callable staticmethod"
            )

        version = Version(
            rollback_callable_code=self._parse_rollback_callable_code(callable),
            has_lib_telemetry=self._has_krkn_lib_obj(KrknTelemetryOpenshift, arguments, kwargs),
            has_kubecli=self._has_krkn_lib_obj(KrknKubernetes, arguments, kwargs),
            has_scenario_telemetry=self._has_krkn_lib_obj(ScenarioTelemetry, arguments, kwargs),
            serialized_arguments=self._parse_arguments(arguments=arguments),
            serialized_kwargs=self._parse_kwargs(kwargs),
        )

        # Generate file content using the VERSION_FILE_TEMPLATE
        file_content = VERSION_FILE_TEMPLATE.format(
            IMPORTS=self._get_imports(version),
            ROLLBACK_CALLABLE_CODE=version.rollback_callable_code,
            KRKN_LIB_VARS=self._get_krkn_lib_vars(version),
            SETUP_KRKN_LIB=self._get_setup_krkn_lib(version),
            ALL_ARGS=self._format_all_args(version),
        )

        # Write the file to the version directory
        version_file_path = self._generate_version_file_name()
        os.makedirs(os.path.dirname(version_file_path), exist_ok=True)

        with open(version_file_path, "w") as f:
            f.write(file_content)

        return version_file_path
